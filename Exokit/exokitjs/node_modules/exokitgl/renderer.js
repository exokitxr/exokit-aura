class Renderer {
    constructor() {

    }

    createShader(str, type) {
        let shader = _gl.createShader(type);

        _gl.shaderSource(shader, str);
        _gl.compileShader(shader);

        if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
            let error = _gl.getShaderInfoLog(shader);
            _gl.deleteShader(shader);
            console.warn(error);
        }

        return shader;
    }

    createProgram(shader) {
        let vsCode = shader.vertexShader;
        let fsCode = shader.fragmentShader;

        let vs = this.createShader(vsCode, _gl.VERTEX_SHADER);
        let fs = this.createShader(fsCode, _gl.FRAGMENT_SHADER);

        let program = _gl.createProgram();
        _gl.attachShader(program, vs);
        _gl.attachShader(program, fs);
        _gl.linkProgram(program);

        if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
            console.error('Could not compile WebGL program. \n\n' + _gl.getProgramInfoLog(program));
        }

        return program;
    }

    setupShader(shader) {
        shader._gl = {program: this.createProgram(shader)};

        for (let key in shader.uniforms) {
            shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
        }
    }

    setupGeom(geom, shader) {
        geom._gl = {};

        for (let key in geom.attributes) {
            let attrib = geom.attributes[key];

            attrib._gl = {};
            attrib._gl.buffer = _gl.createBuffer();

            _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, attrib.array, _gl.STATIC_DRAW);
            _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
        }

        if (geom.index) {
            if (!geom._gl.index) geom._gl.index = _gl.createBuffer();
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW);
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null);
        }
    }

    draw(shader, geometry) {
        if (!shader._gl) this.setupShader(shader);
        if (!geometry._gl) this.setupGeom(geometry, shader);

        shader._gl.texIndex = 0;

        _gl.viewport(0, 0, screen.width * window.devicePixelRatio, screen.height * window.devicePixelRatio);
        _gl.useProgram(shader._gl.program);

        for (let key in shader.uniforms) {
            let uni = shader.uniforms[key];
            let uLoc = shader._gl[key];
            if (uLoc == null) return;

            switch (uni.type) {
                case 'f': _gl.uniform1f(uLoc, uni.value); break;
                case 'v2': _gl.uniform2f(uLoc, uni.value.x, uni.value.y); break;
                case 't':
                    let texture = uni.value;
                    if (texture.needsUpdate || texture.dynamic) texture.update();
                    _gl.activeTexture(_gl[`TEXTURE${shader._gl.texIndex}`]);
                    _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
                    _gl.uniform1i(uLoc, shader._gl.texIndex);
                    shader._gl.texIndex++;
                break;
            }
        }

        _gl.disable(_gl.BLEND);
        _gl.depthMask(false);

        for (let key in geometry.attributes) {
            let attrib = geometry.attributes[key];
            let location = _gl.getAttribLocation(shader._gl.program, key);
            if (location == -1) continue;

            _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
            _gl.vertexAttribPointer(location, attrib.itemSize, _gl.FLOAT, false, 0, 0);
            _gl.enableVertexAttribArray(location);
        }

        if (geometry.index) _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometry._gl.index);

        if (geometry.index) _gl.drawElements(_gl.TRIANGLES, geometry.index.length, _gl.UNSIGNED_SHORT, 0);
        else _gl.drawArrays(_gl.TRIANGLES, 0, geometry.attributes.position.count);
    }
}

exports = {Renderer};
