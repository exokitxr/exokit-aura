const {Quaternion} = require('./math/quaternion');
const {Euler} = require('./math/euler');
const {Matrix4} = require('./math/matrix4');
const {Vector3} = require('./math/vector3');

class Group {

    constructor() {
        this.position = new Vector3();
        this.rotation = new Euler();
        this.quaternion = new Quaternion();
        this.scale = new Vector3(1, 1, 1);

        this._parent = null;

        this.up = new Vector3(0, 1, 0);
        this.isObject3D = true;
        this.children = [];
        this.childrenLength = 0;

        this.modelViewMatrix = new Matrix4();
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();

        this.matrixAutoUpdate = true;
        this.matrixWorldNeedsUpdate = false;
        this.matrixDirty = true;

        this.visible = true;

        this.castShadow = false;

        this.frustumCulled = true;
        this._renderOrder = 0;

        this.worldPos = new Vector3();

        const _this = this;
        this.quaternion.onChange(_ => {
            _this.rotation.setFromQuaternion(_this.quaternion, undefined, false);
        });

        this.rotation.onChange(_ => {
            _this.quaternion.setFromEuler(_this.rotation, false);
        });
    }

    applyMatrix(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
        return this;
    }

    applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
    }

    setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
    }

    setRotationFromMatrix(m) {
        this.quaternion.setFromRotationMatrix(m);
    }

    setRotationFromQuaternion(q) {
        this.quaternion.copy(q);
    }

    localToWorld(v) {
        return v.applyMatrix4(this.matrixWorld);
    }

    worldToLocal(v) {
        let m1 = this.M1 || new Matrix4();
        this.M1 = m1;

        v.applyMatrix4(m1.getInverse(this.matrixWorld));
    }

    add(object) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
            return this;
        }

        if (object === this) return this;

        if (object && object.isObject3D) {
            if (object._parent !== null) object._parent.remove(object);
            object._parent = this;
            this.children.push(object);
            this.childrenLength = this.children.length;
        } else {
            console.error(`Object is not instance of Object3D`, object);
        }

        return this;
    }

    remove(object) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
        }

        this.children.remove(object);
        this.childrenLength = this.children.length;
    }

    getWorldPosition(target) {
        let v = this.V1 || new Vector3();
        this.V1 = v;

        if (!target) target = v;

        this.updateMatrixWorld();
        return target.setFromMatrixPosition(this.matrixWorld);
    }

    getWorldScale(target) {
        let v = this.V1 || new Vector3();
        this.V1 = v;

        let v2 = this.V12|| new Vector3();
        this.V2 = v2;

        let q = this.Q1 || new Quaternion();
        this.Q1 = q;

        if (!target) target = v2;

        this.updateMatrixWorld();
        this.matrixWorld.decompose(v, q, target);

        return target;
    }

    /**
     * @name getWorldQuaternion()
     * @memberof Base3D
     *
     * @function
     * @param {Quaternion} target
     */
    getWorldQuaternion(target) {
        let v = this.V1 || new Vector3();
        this.V1 = v;

        let q = this.Q1 || new Quaternion();
        this.Q1 = q;

        if (!target) target = q;

        this.updateMatrixWorld();
        this.matrixWorld.decompose(v, target, v);

        return target;
    }

    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    }

    updateMatrixWorld() {
        this.updateMatrix();

        if (this._parent === null) {
            this.matrixWorld.copy(this.matrix);
        } else {
            this.matrixWorld.multiplyMatrices(this._parent.matrixWorld, this.matrix);
        }

        let children = this.children;
        for (let i = this.childrenLength-1; i > -1; i--) {
            children[i].updateMatrixWorld();
        }

        this.matrixDirty = false;
    }

    /**
     * @name clone()
     * @memberof Base3D
     */
    clone(recursive) {
        new this.constructor().copy(this, recursive);
    }
}

exports = {Group};
